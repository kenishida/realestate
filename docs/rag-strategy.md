# RAG 導入の戦略と与件整理

実装は行わず、戦略・与件・設計の選択肢だけを整理する。

---

## 1. 与件整理（現状の資産と制約）

### 1.1 データソース（検索候補）

| ソース | 内容 | 取得方法・備考 |
|--------|------|----------------|
| **properties** | 物件概要（価格・住所・間取り・築年数・交通・用途地域など） | 会話に紐づく property_id で取得。構造化フィールド。 |
| **property_analyses** | 投資判断（summary, full_analysis, structured_analysis, investment_purpose, purpose_specific_analysis 等） | property_id / conversation 経由で取得。長文・構造化混在。 |
| **messages** | 会話履歴（role, content, property_id） | conversation_id で時系列取得。ユーザー・アシスタントのやりとり。 |
| **property_external_env** | 周辺環境（学校・病院・スーパー等の一覧、area_overview） | property_id で取得。構造化＋概要テキスト。 |
| **cashflow_simulations** | 収支シミュレーション（想定家賃・利回り・NOI 等） | property_analysis_id で取得。数値・前提の構造化データ。 |

現状、これらは **「ルール分岐＋固定パラメータのAPI」** でしか LLM に渡しておらず、「ユーザーの自由な質問」に対して **検索してから渡す** 層はない。

### 1.2 既存の LLM 呼び出し

- **`/api/analyze`** … 物件URL → スクレイプ → 投資判断テキスト生成。会話文脈なし。
- **`/api/analyze-purpose`** … propertyId / analysisId / purpose を渡し、投資目的別分析を生成。会話文脈なし。

どちらも **Retrieval は行わず、呼び出し時に渡されたパラメータだけ** でプロンプトを組み立てている。

### 1.3 チャットの分岐（フロント）

- URL → analyze
- 想定家賃待ち → 収支計算 or API 保存
- 「収支シミュレーション／利回り」要求 → 想定家賃を聞く
- 投資目的待ち → analyze-purpose
- **上記のどれでもない** → 定型文のみ（ここが RAG の受け口になる）

---

## 2. RAG の目的とユースケース

### 2.1 目的

- **自由な質問**（「この物件の利回りは？」「立地の評価は？」「投資目的別のアドバイスは？」）に、**保有データだけを根拠に** 答える。
- 根拠のない記述（ハルシネーション）を減らすため、**回答は検索したチャンクに基づく** 形に限定する。

### 2.2 想定ユースケース

| 質問例 | 検索したい情報 | 備考 |
|--------|----------------|------|
| この物件の利回りは？ | 収支シミュレーション、分析内の financial_analysis / estimated_yield | 数値は構造化データから。 |
| 立地の評価は？ | structured_analysis.property_overview.location、full_analysis の該当段落 | テキスト＋構造化。 |
| 投資目的別のアドバイスは？ | purpose_specific_analysis、投資目的別セクション | 既に analyze-purpose で生成済み。 |
| 周辺の環境は？ | property_external_env（area_overview、施設一覧） | 構造化＋概要。 |
| この物件の要点をまとめて | summary、full_analysis、物件概要 | 要約・サマリ中心。 |

いずれも **「どの会話のどの物件か」** が決まっている前提（conversation_id → property_id、または property/[id] ページ）で、その範囲のデータを検索対象にする。

---

## 3. Retrieval の対象と単位

### 3.1 検索対象とするもの

- **物件概要** … properties の主要フィールドをテキスト化したもの（1物件あたり1チャンクでも可）。
- **投資判断** … summary、full_analysis の段落、structured_analysis のセクション（立地・価格・建物・final_judgment・purpose_specific_analysis 等）。セクション or 段落単位でチャンク化。
- **投資目的別分析** … purpose_specific_analysis の各キーごと、または advice / merits / risks など。
- **外部環境** … area_overview、施設名・距離などの要約テキスト。
- **収支シミュレーション** … 前提（想定家賃・頭金等）と結果（利回り・NOI 等）を短いテキストにしたもの。
- **会話履歴** … 直近 N 件の (role, content)。RAG の「文脈」としてプロンプトにそのまま載せるか、要約して載せるかは設計次第。

### 3.2 チャンクの単位

- **段落・セクション単位** … full_analysis や purpose_specific_analysis は「## 1. メリット・デメリット」などで区切られているので、見出し＋本文を1チャンクにしやすい。
- **ドキュメント単位** … 物件概要は1物件＝1まとまり。小さいので1チャンクでよい。
- **構造化データ** … JSON の一部を「項目: 値」のテキストに変換してチャンクにすると、ベクトル検索でも扱いやすい。

### 3.3 メタデータ（フィルタ・表示用）

各チャンクに持たせるとよいものの例:

- `property_id` … どの物件か。
- `source` … properties | property_analyses | messages | external_env | cashflow_simulations。
- `section` … 例: "location" / "price" / "purpose_analysis" / "summary"。
- `conversation_id` … 会話スコープのフィルタ用（必要なら）。

---

## 4. Retrieval の方式

### 4.1 キーワードのみ（ベクトルなし）

- ユーザー発話や会話履歴からキーワードを抽出し、**対象テーブルを限定**（例: 「利回り」→ 収支シミュレーション＋分析内 financial 系）。
- 該当するレコード・フィールドをそのままプロンプトに載せる。
- **メリット**: 実装が簡単。既存 DB だけで完結。  
- **デメリット**: 言い回しが違うと拾えない。「周辺の雰囲気は？」と「立地の雰囲気は？」の扱いが難しい。

### 4.2 ベクトル検索

- チャンクを **embedding** して保存。ユーザー発話（＋必要なら直近の会話）も embedding し、**類似度で上位 K 件** を取得。
- **メリット**: 言い回しが多少違っても関連チャンクを取れる。  
- **デメリット**: embedding モデル・インデックス・ストアの導入が必要。チャンクの更新（分析の再生成など）とインデックスの同期が必要。

### 4.3 ハイブリッド（推奨の方向性）

- **第一段階**: キーワード or 会話コンテキストで **「どの物件・どの会話か」** と **「どのソースか」** を限定（例: この conversation の property_id → その property / analysis / external_env / cashflow）。
- **第二段階**:  
  - ソースが少ないうちは **全チャンクをプロンプトに載せる**（検索なし）。  
  - チャンクが増えたら、キーワードマッチ or ベクトル類似度で **上位 K 件に絞る**。
- 会話履歴は **必ずしもベクトル化せず、直近 N 件をそのままプロンプトに含める** だけでよい。

---

## 5. Augment の対象（どの LLM 呼び出しを拡張するか）

### 5.1 新規 API を1本用意する形（推奨）

- **例**: `POST /api/chat/rag` または `POST /api/conversation/[id]/answer`。
- **入力**: conversation_id（または property_id）、直近メッセージ履歴、**ユーザー発話**。
- **処理**:  
  1. 会話に紐づく property_id を特定。  
  2. その property に関するチャンクを取得（Retrieval）。  
  3. プロンプトに「検索結果（チャンク）」＋「直近の会話」＋「ユーザー発話」を組み込み、**回答だけ** を Gemini で生成。  
  4. 回答を messages に保存し、フロントに返す。
- **既存 API**: `/api/analyze` と `/api/analyze-purpose` は **そのまま** にし、チャットの「その他」分岐からだけこの RAG API を呼ぶ。

### 5.2 プロンプト設計の要点

- **システムプロンプト**: 「以下の [検索結果] と [会話履歴] だけを根拠に答える。書かれていないことは推測で書かず、『情報がありません』と答える。」など。
- **検索結果**: チャンクを「ソース: 〜」「内容: 〜」の形で並べ、トークン上限内に収める。
- **会話履歴**: 直近 5〜10 ターン程度をそのまま列挙。
- **ユーザー発話**: 最後の1件を「今回の質問」として明示する。

---

## 6. 設計上の選択肢と推奨

| 項目 | 選択肢 | 推奨・メモ |
|------|--------|------------|
| **チャンクの保存先** | Supabase (pgvector) / 別サービス (Pinecone, Weaviate 等) | 既存が Supabase なので **pgvector** で揃えると運用が楽。 |
| **Embedding** | Gemini embedding / OpenAI / 他 | 既に Gemini を使っているなら **Gemini embedding** で統一可能。 |
| **インデックスタイミング** | 分析・外部環境の作成・更新時に都度投入 / バッチ | まずは **作成・更新時に都度投入** でよい。会話履歴は RAG 用にインデックスしない（直近 N 件をそのまま渡す）でも可。 |
| **Retrieval の段階** | 最初からベクトル / まずキーワード＋全チャンクで試す | **まずキーワード＋「その会話の物件の全チャンク」を渡す** 最小構成で効果を見て、必要ならベクトルを追加。 |
| **RAG を呼ぶ条件** | 常に「その他」で RAG / 意図が「質問」と分かったときだけ RAG | 最初は **「その他」のときはすべて RAG API に流す** でよい。物件が未紐づきのときは「物件URLを送ってください」とだけ返す。 |

---

## 7. まとめ（戦略の要約）

1. **与件**: 物件・分析・外部環境・収支・会話履歴は既に DB にあり、会話単位で property_id が紐づく。RAG 用の「検索して LLM に渡す」層だけがない。
2. **目的**: 自由な質問に、**保有データのみを根拠に** 答え、ハルシネーションを抑える。
3. **Retrieval**: 対象は「その会話の物件」に限定。チャンクは段落・セクション・構造化のテキスト化。まずはキーワード＋全チャンクで試し、必要なら pgvector でベクトル検索を追加。
4. **Augment**: 新規 API 1本（例: `/api/chat/rag`）で、「検索結果＋会話履歴＋発話」をプロンプトに組み、回答を生成。既存の analyze / analyze-purpose は変更しない。
5. **チャット側**: 現行の URL / 収支 / 投資目的 の分岐はそのままにし、「どれにも当てはまらない発話」を RAG API に渡す。

この方針で与件と戦略を揃えたうえで、次のステップで「チャンクスキーマ」「API 仕様」「プロンプト文言」を具体化するとよい。

---

## 8. URL 受信後のフローを RAG に寄せる戦略

**問い**: 最初に物件 URL を受け取ったあと、「投資目的を訪ねる」「収支シミュレーションを出す」などを、RAG に任せるべきか。

### 8.1 結論（推奨戦略）

**「URL 受信 → 1回目の投資判断取得」までは現状どおりにし、その後の発話は原則すべて RAG に渡す。**

- **URL 受信時**: これまでどおり `/api/analyze` を呼び、投資判断を取得。ここはルールのまま。
- **その後の発話**: 「投資目的を教えて」「収支シミュレーションを出して」「利回り重視でこの物件はどう？」などは、**すべて RAG 用 API の入力**にする。
- RAG の役割は **意図の解釈** と **文脈に応じた応答・アクション指示**。実際の「投資目的別分析の生成」「収支シミュレーションの計算」は、既存 API を **RAG が指示したときにだけ** 呼ぶ。

これにより、「投資目的を先に聞く／収支を先に出す」といった **順番の固定** をやめ、ユーザーの言い方に合わせて柔軟に対応できる。

### 8.2 なぜ RAG に寄せるか

- **キーワード分岐の限界**: 「利回り重視でこの物件はどう？」と「利回りを教えて」をキーワードだけで切り分けると、どちらを先に判定してももう片方で誤動作する（前述のトレードオフ）。
- **順番を決めない**: ユーザーが「まず収支シミュレーション」「まず投資目的で評価」のどちらを言っても、RAG（＝LLM）が意図を解釈し、適切な「次の一手」（質問する／API を呼ぶ／検索結果だけで答える）を決められる。
- **一貫した窓口**: 「投資目的を訪ねる」も「収支シミュレーションを出す」も「単なる質問」も、同じ RAG API に流すことで、意図の曖昧さを一箇所で扱える。

### 8.3 RAG がやること・やらないこと

| 役割 | 内容 |
|------|------|
| **やること** | 発話の意図解釈、会話・物件・分析などの検索（Retrieval）、「何をすべきか」の決定（投資目的を聞く／収支を聞く／既存データで答える／API を呼ぶ）、返答文の生成。 |
| **やらないこと** | 投資判断の初回生成（`/api/analyze` は URL 受信時のルールのまま）、収支の数値計算（既存の計算ロジック・API を呼ぶだけ）、DB の更新（メッセージ保存は API 側で実施）。 |

### 8.4 フローのイメージ

1. ユーザーが **物件 URL を送る** → 従来どおり `/api/analyze`。分析結果と「この物件について知りたいことはありますか？」のような一言を返す（または RAG に「初回挨拶」を生成させる）。
2. ユーザーが **「利回り重視でこの物件はどう？」** と送る → RAG API に発話＋会話履歴＋物件・分析チャンクを渡す。意図が「投資目的（利回り重視）での評価」と解釈されれば、バックエンドで `/api/analyze-purpose` を呼び、その結果を RAG のコンテキストに含めて返答文を生成。
3. ユーザーが **「収支シミュレーションを出して」** と送る → 同様に RAG で意図を解釈。「収支シミュレーション要求」かつ「想定家賃未入力」なら、RAG が「想定家賃（月額・円）を教えてください」と返す。ユーザーが家賃を入力したら、その発話も RAG に渡し、意図が「家賃の入力」と分かれば既存の収支 API を呼び、結果をコンテキストに含めて「〇〇円で計算しました。右の収支シミュレーションをご確認ください」のような返答を生成。
4. **「投資目的を教えて」とこちらのから聞くタイミング** も、RAG の返答生成に任せる。例: 分析結果を返した直後のシステムメッセージや、RAG のプロンプトで「まだ投資目的が未入力なら、適宜たずねてよい」と指示しておく。

### 8.5 まとめ

- **URL の次からは RAG に寄せる**: 投資目的を訪ねるのも、収支シミュレーションを出すのも、順番や言い回しに依存しない形で RAG が意図を解釈し、必要なら既存 API を呼ぶ。
- **分析の初回生成だけはルールのまま**: URL 受信 → `/api/analyze` は変えない。
- **計算とDB更新は既存API**: 収支計算・投資目的別分析の生成・メッセージ保存は、RAG が「この意図ならこの API」と判断したときに呼ぶ。

この戦略で、「最初に URL を受け取ったあと、そのあとは RAG で投資目的を訪ねたり収支シミュレーションを出したりする」形に一本化できる。
